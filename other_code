/*
CMPSC 473 PROJECT 3
By:
	Daniel Colom
	Kanishk Chandra
	Ishaank Chaudhary
Date: 4/27/17
*/

#pragma once

#include "virtualMemoryManagerInterface.hpp"
#include <iostream>
#include <cassert>
#include <cmath>
#include <list>

using namespace std;

typedef struct {
	unsigned long long pageNumber;	//page that occupies the frame
	unsigned long long frameNumber;	//# of frame that holds said page
} frame;


class memoryManager : public virtualMemoryManagerInterface
{
public:
	//extend the constructor
	memoryManager(ReplacementPolicy p, unsigned int pS, unsigned int nF, unsigned int vA) : virtualMemoryManagerInterface(p, pS, nF, vA)
	{

	};

	//Implementation of the memoryAccess Function
	//The list of frames (memMap) is used to implement the policies:
	//		In both policies, we REMOVE FROM FRONT, and ADD TO THE BACK
	unsigned long long memoryAccess(unsigned long long address)
	{
		unsigned long long physAddress;		//final addr to return
		unsigned long long currentPage;		//Current page being worked on
		unsigned long long currentFrame;	//Current frame being worked on
		unsigned long long currentOffset;	//Associated offset
		bool found = false;					//Is page found in a frame already?
		list<frame>::iterator iter;			//STD iterator for the memMap list of frames
		frame newFrame;						//New frame to be added (if applicable)

		//get page # from address via bit shift
		currentPage = address;
		currentPage = currentPage >> N;

		//get offset from address via bit shift
		unsigned long long temp = currentPage << N;		//temp = just the page part
		currentOffset = address - temp;					//leave just the offset



		//See if frame already in memMap
		for (iter = memMap.begin(); iter != memMap.end(); ++iter)
		{
			if (iter->pageNumber == currentPage)
			{
				found = true;
				currentFrame = iter->frameNumber;

				//FOR LRU, NEED TO PUT PUSH ACCESSED FRAME TO END OF LIST
				//this signifies that it is was just accessed
				if (policy == LRU) {
					memMap.splice(memMap.end(), memMap, iter);
				}
			}
		}

		//if not found in memMap list, need to either add if not full or replace if full
		if (found == false)
		{
			if (memMapSize < numFrames)	//if frames not full yet (Cold start), add it
			{
				newFrame.pageNumber = currentPage;
				newFrame.frameNumber = memMapSize;		//number frames 0 -> numFrames-1
				currentFrame = newFrame.frameNumber;
				memMap.push_back(newFrame);
				memMapSize++;
			}
			else {		//if they are full need to replace
				currentFrame = memMap.begin()->frameNumber;
				memMap.pop_front();
				newFrame.frameNumber = currentFrame;
				newFrame.pageNumber = currentPage;
				memMap.push_back(newFrame);
				swap(currentFrame, currentPage);
			}
		}
		
		
		//cout << "The currentFrame is " << currentFrame << endl;
		//cout << "The currentOffset is " << currentOffset << endl;
		


		//Get phys address
		physAddress = currentFrame << N | currentOffset;

		return physAddress;
	}


protected:
	list<frame> memMap = {};
	unsigned long long memMapSize = 0;
};




int main() {
	cout << "------------------TEST 1--------------------" << endl;
	memoryManager mManager(LRU, 1, 4, 4);
	int const addressCount = 7;
	unsigned long long A[addressCount] = {0, 2, 4, 6, 2, 10, 12};

	for (int i = 0; i < addressCount; i++)
	{
		cout << "Address is :: " << mManager.memoryAccess(A[i]) << endl << endl;
	}


	cout << "------------------TEST 2--------------------" << endl;
	memoryManager mManager2(LRU, 2, 3, 4);
	int const addressCount2 = 7;
	unsigned long long A2[addressCount2] = { 0, 8, 4, 1, 9, 6, 10 };

	for (int i = 0; i < addressCount2; i++)
	{
		cout << "Address is :: " << mManager2.memoryAccess(A2[i]) << endl << endl;
	}

	int pause;
	cin >> pause;
	return 0;
}

